<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RobustBlindVerification.jl</title><meta name="title" content="Home · RobustBlindVerification.jl"/><meta property="og:title" content="Home · RobustBlindVerification.jl"/><meta property="twitter:title" content="Home · RobustBlindVerification.jl"/><meta name="description" content="Documentation for RobustBlindVerification.jl."/><meta property="og:description" content="Documentation for RobustBlindVerification.jl."/><meta property="twitter:description" content="Documentation for RobustBlindVerification.jl."/><meta property="og:url" content="https://fieldofnodes.github.io/RobustBlindVerification.jl/"/><meta property="twitter:url" content="https://fieldofnodes.github.io/RobustBlindVerification.jl/"/><link rel="canonical" href="https://fieldofnodes.github.io/RobustBlindVerification.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RobustBlindVerification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Robust-Blind-Verification"><a class="docs-heading-anchor" href="#Robust-Blind-Verification">Robust Blind Verification</a><a id="Robust-Blind-Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-Blind-Verification" title="Permalink"></a></h1><p>Package documentation</p><p>Docs for package</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MetaGraph-Tuple{Client, MBQCResourceState}" href="#RobustBlindVerification.MetaGraph-Tuple{Client, MBQCResourceState}"><code>RobustBlindVerification.MetaGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MetaGraph(::Client, resource::MBQCResourceState)</code></pre><p>This function creates a MetaGraph from a given MBQCResourceState. It extracts the graph from the resource state and wraps it in a MetaGraph.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client object.</li><li><code>resource::MBQCResourceState</code>: The MBQC resource state containing the graph.</li></ul><p><strong>Examples</strong></p><p><code>julia client = Client() resource = MBQCResourceState(graph) MetaGraph(client, resource)</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_correction_vertices!-Tuple{Client, Any, MBQCResourceState}" href="#RobustBlindVerification.add_correction_vertices!-Tuple{Client, Any, MBQCResourceState}"><code>RobustBlindVerification.add_correction_vertices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_correction_vertices!(::Client, mg, resource::MBQCResourceState)</code></pre><p>This function adds correction vertices to the meta graph for a client in the MBQC model.  It iterates over each vertex in the resource, gets the correction vertices for each,  and sets these as properties in the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
add_correction_vertices!(client, mg, resource)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L600-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_flow_vertex!-Tuple{Client, Any, MBQCResourceState, Union{BackwardFlow, ForwardFlow}}" href="#RobustBlindVerification.add_flow_vertex!-Tuple{Client, Any, MBQCResourceState, Union{BackwardFlow, ForwardFlow}}"><code>RobustBlindVerification.add_flow_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_flow_vertex!(::Client, mg, resource::MBQCResourceState, flow_type::Union{ForwardFlow,BackwardFlow})</code></pre><p>This function adds a flow vertex to the meta graph for a client in the MBQC model.  It first converts the flow type to a symbol, then iterates over each vertex in the resource.  For each vertex, it gets the verified flow output and sets this as a property in the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li><li><code>flow_type::Union{ForwardFlow,BackwardFlow}</code>: The flow type to be added.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
flow_type = ForwardFlow()
add_flow_vertex!(client, mg, resource, flow_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L530-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_flow_vertex!-Tuple{Client, Any, MBQCResourceState}" href="#RobustBlindVerification.add_flow_vertex!-Tuple{Client, Any, MBQCResourceState}"><code>RobustBlindVerification.add_flow_vertex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_flow_vertex!(::Client, mg, resource::MBQCResourceState)</code></pre><p>This function adds both forward and backward flow vertices to the meta graph for a client in the MBQC model.  It calls the <code>add_flow_vertex!</code> function twice, once with <code>ForwardFlow</code> and once with <code>BackwardFlow</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
add_flow_vertex!(client, mg, resource)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L572-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_noise!-Tuple{Client, NoiseModel}" href="#RobustBlindVerification.add_noise!-Tuple{Client, NoiseModel}"><code>RobustBlindVerification.add_noise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_noise!(client::Client, noise_model::NoiseModel)</code></pre><p>This function adds noise to a quantum system according to the specified noise model. It calls the <code>add_noise!</code> function  with a new client and the given noise model as arguments.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the noise is being added.</li><li><code>noise_model::NoiseModel</code>: The noise model to be used.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
noise_model = NoiseModel()
add_noise!(client, noise_model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L217-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_noise!-Tuple{Client, Union{Damping, Dephasing, Depolarising, Pauli}, QubitNoiseParameters}" href="#RobustBlindVerification.add_noise!-Tuple{Client, Union{Damping, Dephasing, Depolarising, Pauli}, QubitNoiseParameters}"><code>RobustBlindVerification.add_noise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_noise!(client::Client, model::Union{Damping,Dephasing,Depolarising,Pauli}, params::QubitNoiseParameters)</code></pre><p>This function adds noise to a quantum system. The noise model can be one of Damping, Dephasing, Depolarising, or Pauli.  The function throws an error if the noise type is not SingleQubit. It then iterates over the range of qubits represented  in the backend and adds noise to each qubit according to the specified model and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the noise is being added.</li><li><code>model::Union{Damping,Dephasing,Depolarising,Pauli}</code>: The noise model to be used.</li><li><code>params::QubitNoiseParameters</code>: The parameters for the noise model.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
model = Damping()
params = QubitNoiseParameters(SingleQubit(), backend)
add_noise!(client, model, params)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L185-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_output_qubits!-Tuple{Client, Any, MBQCResourceState}" href="#RobustBlindVerification.add_output_qubits!-Tuple{Client, Any, MBQCResourceState}"><code>RobustBlindVerification.add_output_qubits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_output_qubits!(::Client, mg, resource::MBQCResourceState)</code></pre><p>This function adds output qubits to the meta graph for a client in the MBQC model.  It retrieves the output indices from the resource graph and sets the <code>:output_inds</code> property of the meta graph to these indices.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the property will be added.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
add_output_qubits!(client, mg, resource)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L833-L854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.add_round_type!-Tuple{Client, Any, Any}" href="#RobustBlindVerification.add_round_type!-Tuple{Client, Any, Any}"><code>RobustBlindVerification.add_round_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_round_type!(::Client, mg, round_type)</code></pre><p>This function adds a round type to the meta graph for a client in the MBQC model.  It sets the <code>:round_type</code> property of the meta graph to the specified round type.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the property will be added.</li><li><code>round_type</code>: The round type to be added to the meta graph.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
mg = MetaGraphs.MetaGraph(graph)
round_type = &quot;round1&quot;
add_round_type!(client, mg, round_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L805-L826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.c_iterator-Tuple{Any}" href="#RobustBlindVerification.c_iterator-Tuple{Any}"><code>RobustBlindVerification.c_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c_iterator(N)</code></pre><p>Create a C based index iterator that generates numbers from 0 to <code>N-1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: The upper limit for the circular iterator.</li></ul><p><strong>Returns</strong></p><p>A circular iterator that generates numbers from 0 to <code>N-1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a circular iterator
N = 5
iterator = c_iterator(N)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/c_utility_functions.jl#L36-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.c_shift_index-Tuple{Any}" href="#RobustBlindVerification.c_shift_index-Tuple{Any}"><code>RobustBlindVerification.c_shift_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c_shift_index(n::Int)</code></pre><p>Compute the shifted index <code>n-1</code> for circular indexing.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int</code>: The input index.</li></ul><p><strong>Returns</strong></p><p>The shifted index <code>n-1</code> for circular indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Compute the shifted index
n = 3
shifted_index = c_shift_index(n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/c_utility_functions.jl#L10-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.compute_angle_δᵥ-Tuple{ComputationRound, InputQubits, Vararg{Any, 6}}" href="#RobustBlindVerification.compute_angle_δᵥ-Tuple{ComputationRound, InputQubits, Vararg{Any, 6}}"><code>RobustBlindVerification.compute_angle_δᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computation of δᵥ Case</p><ol><li>Round ≡ Computation ∩ Qubit ∈ Input set  → δᵥ = ϕᵥ + (θᵥ + xᵥπ) + rᵥπ</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_update_angle.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.compute_angle_δᵥ-Tuple{ComputationRound, NoInputQubits, Vararg{Any, 5}}" href="#RobustBlindVerification.compute_angle_δᵥ-Tuple{ComputationRound, NoInputQubits, Vararg{Any, 5}}"><code>RobustBlindVerification.compute_angle_δᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computation of δᵥ Case</p><ol><li>Round ≡ Computation ∩ Qubit ∉ Input set  → δᵥ = ϕᵥ′ + θᵥ + rᵥπ</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_update_angle.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.compute_angle_δᵥ-Tuple{MBQC, Union{InputQubits, NoInputQubits}, Any, Any, Any}" href="#RobustBlindVerification.compute_angle_δᵥ-Tuple{MBQC, Union{InputQubits, NoInputQubits}, Any, Any, Any}"><code>RobustBlindVerification.compute_angle_δᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MBQC compute updated angle</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_update_angle.jl#L93-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.compute_angle_δᵥ-Tuple{TestRound, DummyQubit, Any}" href="#RobustBlindVerification.compute_angle_δᵥ-Tuple{TestRound, DummyQubit, Any}"><code>RobustBlindVerification.compute_angle_δᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computation of δᵥ Case</p><ol><li>Round ≡ Test ∩ Qubit ≡ Dummy  → δᵥ = {kπ/r | k ∼ U(0..7)}</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_update_angle.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.compute_angle_δᵥ-Tuple{TestRound, TrapQubit, Any, Any}" href="#RobustBlindVerification.compute_angle_δᵥ-Tuple{TestRound, TrapQubit, Any, Any}"><code>RobustBlindVerification.compute_angle_δᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computation of δᵥ Case</p><ol><li>Round ≡ Test ∩ Qubit ≡ Trap  → δᵥ = θᵥ + rᵥπ</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_update_angle.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.compute_backward_flow-Tuple{Any, Any, Any}" href="#RobustBlindVerification.compute_backward_flow-Tuple{Any, Any, Any}"><code>RobustBlindVerification.compute_backward_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_backward_flow(graph, forward_flow, vertex)</code></pre><p>This function computes the backward flow of a given vertex in a graph.  It first finds the neighbors of the vertex and checks if the vertex is in the forward flow of any of its neighbors.  If it is not, the function returns 0.  If it is, the function finds the index of the vertex in the forward flow of its neighbors.  If the vertex is not in the flow of the neighbors, an error is thrown.  If there is more than one past vertex found, an error is thrown.  Otherwise, the function returns the first past vertex.</p><p><strong>Arguments</strong></p><ul><li><code>graph</code>: The graph.</li><li><code>forward_flow</code>: The forward flow function.</li><li><code>vertex</code>: The vertex for which to compute the backward flow.</li></ul><p><strong>Returns</strong></p><ul><li>The first past vertex if it exists, 0 otherwise.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">graph = Graph(5)
forward_flow = (n -&gt; n + 1)
vertex = 3
backward_flow_vertex = compute_backward_flow(graph, forward_flow, vertex)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L491-L517">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.convert_flow_type_symbol-Tuple{Client, Union{BackwardFlow, ForwardFlow}}" href="#RobustBlindVerification.convert_flow_type_symbol-Tuple{Client, Union{BackwardFlow, ForwardFlow}}"><code>RobustBlindVerification.convert_flow_type_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_flow_type_symbol(::Client, flow_type::Union{ForwardFlow,BackwardFlow})</code></pre><p>This function converts a flow type (either ForwardFlow or BackwardFlow) into a symbol.  The conversion process involves converting the flow type to a string, removing parentheses,  adding an underscore before &quot;Flow&quot;, converting to lowercase, and finally converting to a symbol.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>flow_type::Union{ForwardFlow,BackwardFlow}</code>: The flow type to be converted.</li></ul><p><strong>Returns</strong></p><ul><li>A Symbol representing the flow type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
flow_type = ForwardFlow()
flow_sym = convert_flow_type_symbol(client, flow_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L458-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.create_quantum_env-Tuple{Client}" href="#RobustBlindVerification.create_quantum_env-Tuple{Client}"><code>RobustBlindVerification.create_quantum_env</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_quantum_env(client::Client)</code></pre><p>Create a new quantum environment using the QuEST environment creation function.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the quantum environment is being created.</li></ul><p><strong>Returns</strong></p><ul><li>A new quantum environment.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
env = create_quantum_env(client)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.create_quantum_state-Tuple{Client, DensityMatrix, Any, Any}" href="#RobustBlindVerification.create_quantum_state-Tuple{Client, DensityMatrix, Any, Any}"><code>RobustBlindVerification.create_quantum_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_quantum_state(client::Client, density_matrix::DensityMatrix, quantum_env, num_qubits)</code></pre><p>Create a quantum state using a density matrix representation.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client object representing the quantum computing service.</li><li><code>density_matrix::DensityMatrix</code>: The density matrix object representing the quantum state.</li><li><code>quantum_env</code>: The quantum environment object.</li><li><code>num_qubits</code>: The number of qubits to be used in the quantum state.</li></ul><p><strong>Returns</strong></p><ul><li>The quantum state represented as a density matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
env = create_quantum_env(client)
state = create_quantum_state(client, DensityMatrix(), env, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L47-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.create_quantum_state-Tuple{Client, StateVector, Any, Any}" href="#RobustBlindVerification.create_quantum_state-Tuple{Client, StateVector, Any, Any}"><code>RobustBlindVerification.create_quantum_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_quantum_state(client::Client, state::StateVector, quantum_env, num_qubits)</code></pre><p>Create a new quantum state as a state vector using the QuEST function <code>createQureg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the quantum state is being created.</li><li><code>state::StateVector</code>: Indicates that the quantum state should be created as a state vector.</li><li><code>quantum_env</code>: The quantum environment in which the quantum state is being created.</li><li><code>num_qubits</code>: The number of qubits in the quantum state.</li></ul><p><strong>Returns</strong></p><ul><li>A new quantum state as a state vector.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
env = create_quantum_env(client)
state = create_quantum_state(client, StateVector(), env, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.draw_bit-Tuple{}" href="#RobustBlindVerification.draw_bit-Tuple{}"><code>RobustBlindVerification.draw_bit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Draw random bit 0 or 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_random_draw_functions_angle_bits.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.draw_dᵥ-Tuple{}" href="#RobustBlindVerification.draw_dᵥ-Tuple{}"><code>RobustBlindVerification.draw_dᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Draw random bit 0 or 1 for dummy</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_random_draw_functions_angle_bits.jl#L29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.draw_rᵥ-Tuple{}" href="#RobustBlindVerification.draw_rᵥ-Tuple{}"><code>RobustBlindVerification.draw_rᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Draw random bit 0 or 1 for trap</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_random_draw_functions_angle_bits.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.draw_θᵥ-Tuple{}" href="#RobustBlindVerification.draw_θᵥ-Tuple{}"><code>RobustBlindVerification.draw_θᵥ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">For draw θ a multiple of kπ/4, k ∈ 0..7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_random_draw_functions_angle_bits.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.entangle_graph!-Tuple{Client, Any}" href="#RobustBlindVerification.entangle_graph!-Tuple{Client, Any}"><code>RobustBlindVerification.entangle_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entangle_graph!(::Client, mg)</code></pre><p>This function entangles the quantum state of a meta graph for a client in the MBQC model.  It first retrieves the quantum state from the meta graph and creates a graph from the meta graph.  Then, for each edge in the graph, it applies a controlled phase flip operation on the source and destination vertices.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
mg = MetaGraphs.MetaGraph(graph)
entangle_graph!(client, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L775-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.generate_property_graph!-Tuple{Client, Any, MBQCResourceState, Union{DensityMatrix, StateVector}}" href="#RobustBlindVerification.generate_property_graph!-Tuple{Client, Any, MBQCResourceState, Union{DensityMatrix, StateVector}}"><code>RobustBlindVerification.generate_property_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_property_graph!(::Client, round_type, resource::MBQCResourceState, state_type::Union{StateVector,DensityMatrix})</code></pre><p>This function generates a property graph for a client in the MBQC model based on the round type.  It first creates a meta graph from the resource and adds the round type to it.  Then, it adds output qubits, sets the vertex type and IO qubits type, initializes the qubits,  adds flow vertices and correction vertices, initializes measurement outcomes,  and initializes the quantum state of the meta graph.  This function is run at the beginning of every round.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>round_type</code>: The round type.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li><li><code>state_type::Union{StateVector,DensityMatrix}</code>: The type of quantum state to create.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
round_type = &quot;round1&quot;
state_type = StateVector()
generate_property_graph!(client, round_type, resource, state_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L864-L891">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.generate_property_graph!-Tuple{Client, MBQC, MBQCResourceState, Union{DensityMatrix, StateVector}}" href="#RobustBlindVerification.generate_property_graph!-Tuple{Client, MBQC, MBQCResourceState, Union{DensityMatrix, StateVector}}"><code>RobustBlindVerification.generate_property_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_property_graph!(::Client, round_type::MBQC, resource::MBQCResourceState, state_type::Union{StateVector,DensityMatrix})</code></pre><p>This function generates a property graph for a client in the MBQC model based on the round type.  It first creates a meta graph from the resource and adds the round type to it.  Then, it adds output qubits, sets the vertex type and IO qubits type, initializes the qubits,  adds flow vertices and correction vertices, initializes measurement outcomes,  initializes the quantum state of the meta graph, and entangles the graph.  This function is run at the beginning of every round.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>round_type::MBQC</code>: The round type.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li><li><code>state_type::Union{StateVector,DensityMatrix}</code>: The type of quantum state to create.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
round_type = MBQC()
state_type = StateVector()
generate_property_graph!(client, round_type, resource, state_type)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L912-L939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.generate_random_greedy_color-Tuple{Any, Any}" href="#RobustBlindVerification.generate_random_greedy_color-Tuple{Any, Any}"><code>RobustBlindVerification.generate_random_greedy_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_random_greedy_color(g, reps)</code></pre><p>This function generates a random greedy coloring of a graph. It uses the <code>random_greedy_color</code> function from the Graphs package.</p><p><strong>Arguments</strong></p><ul><li><code>g</code>: The graph to be colored.</li><li><code>reps</code>: The number of repetitions for the random greedy coloring algorithm.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">g = Graphs.grid_graph((5,5))
reps = 10
generate_random_greedy_color(g, reps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.get_edge_iterator-Tuple{MBQCResourceState}" href="#RobustBlindVerification.get_edge_iterator-Tuple{MBQCResourceState}"><code>RobustBlindVerification.get_edge_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_edge_iterator(resource::MBQCResourceState)

Retrieve an iterator over the edges in an MBQC resource state.

# Arguments
- `resource::MBQCResourceState`: An MBQC resource state containing the graph representation of the resource.

# Returns
An iterator over the edges of the resource state&#39;s graph.

# Examples
```julia
# Create an MBQC resource state
graph = MBQCGraph(...)
flow = MBQCFlow(...)
angles = MBQCAngles(...)
resource = MBQCResourceState(graph, flow, angles)

# Get the edge iterator
edge_iterator = get_edge_iterator(resource)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_struct_utility_functions.jl#L78-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.get_number_vertices-Tuple{MBQCResourceState}" href="#RobustBlindVerification.get_number_vertices-Tuple{MBQCResourceState}"><code>RobustBlindVerification.get_number_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_number_qubits(resource::MBQCResourceState)

Retrieve the number of qubits in an MBQC resource state.

# Arguments
- `resource::MBQCResourceState`: An MBQC resource state containing the graph representation of the resource.

# Returns
The number of qubits in the resource state.

# Examples
```julia
# Create an MBQC resource state
graph = MBQCGraph(...)
flow = MBQCFlow(...)
angles = MBQCAngles(...)
resource = MBQCResourceState(graph, flow, angles)

# Get the number of qubits
num_qubits = get_number_qubits(resource)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_struct_utility_functions.jl#L50-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.get_random_coloring-Tuple{Vector{Vector{Int64}}}" href="#RobustBlindVerification.get_random_coloring-Tuple{Vector{Vector{Int64}}}"><code>RobustBlindVerification.get_random_coloring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_random_coloring(c::Vector{Vector{Int64}})</code></pre><p>This function selects a random coloring from a vector of colorings.</p><p><strong>Arguments</strong></p><ul><li><code>c::Vector{Vector{Int64}}</code>: The vector of colorings.</li></ul><p><strong>Examples</strong></p><p><code>julia c = [[1, 2, 1], [2, 1, 2], [1, 2, 2]] get_random_coloring(c)</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L47-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.get_vertex_iterator-Tuple{MBQCResourceState}" href="#RobustBlindVerification.get_vertex_iterator-Tuple{MBQCResourceState}"><code>RobustBlindVerification.get_vertex_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vertex_iterator(resource::MBQCResourceState)

Retrieve an iterator over the vertices in an MBQC resource state.

# Arguments
- `resource::MBQCResourceState`: An MBQC resource state containing the graph representation of the resource.

# Returns
An iterator over the vertices of the resource state&#39;s graph.

# Examples
```julia
# Create an MBQC resource state
graph = MBQCGraph(...)
flow = MBQCFlow(...)
angles = MBQCAngles(...)
resource = MBQCResourceState(graph, flow, angles)

# Get the vertex iterator
vertex_iterator = get_vertex_iterator(resource)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_struct_utility_functions.jl#L107-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.get_vertex_neighbours-Tuple{MBQCResourceState, Any}" href="#RobustBlindVerification.get_vertex_neighbours-Tuple{MBQCResourceState, Any}"><code>RobustBlindVerification.get_vertex_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_vertex_neighbours(resource::MBQCResourceState, vertex)

Retrieve the neighbors of a given vertex in an MBQC resource state.

# Arguments
- `resource::MBQCResourceState`: An MBQC resource state containing the graph representation of the resource.
- `vertex`: The vertex for which to retrieve the neighbors.

# Returns
An array of vertices representing the neighbors of the specified vertex.

# Examples
```julia
# Create an MBQC resource state
graph = MBQCGraph(...)
flow = MBQCFlow(...)
angles = MBQCAngles(...)
resource = MBQCResourceState(graph, flow, angles)

# Get the neighbors of a vertex
vertex = 1
neighbors = get_vertex_neighbours(resource, vertex)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_struct_utility_functions.jl#L137-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_measurement_outcomes!-Tuple{Client, Any, MBQCResourceState}" href="#RobustBlindVerification.init_measurement_outcomes!-Tuple{Client, Any, MBQCResourceState}"><code>RobustBlindVerification.init_measurement_outcomes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_measurement_outcomes!(::Client, mg, resource::MBQCResourceState)</code></pre><p>This function initializes the measurement outcomes in the meta graph for a client in the MBQC model.  It iterates over each vertex in the resource and sets the <code>:outcome</code> property of each vertex in the meta graph to <code>Int64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
init_measurement_outcomes!(client, mg, resource)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L633-L654">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_plus_phase_state!-Tuple{NoPhase, Any, Any}" href="#RobustBlindVerification.init_plus_phase_state!-Tuple{NoPhase, Any, Any}"><code>RobustBlindVerification.init_plus_phase_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_plus_phase_state!(nophase::NoPhase, qureg, qᵢ)</code></pre><p>This function initializes a quantum state to a superposition state (|+⟩ state) without adding any phase.  It applies a Hadamard gate to the qubit, putting it into a superposition state.</p><p><strong>Arguments</strong></p><ul><li><code>nophase::NoPhase</code>: The NoPhase object indicating that no phase is to be added.</li><li><code>qureg</code>: The quantum register containing the qubit.</li><li><code>qᵢ</code>: The index of the qubit in the quantum register.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">nophase = NoPhase()
qureg = createQureg(1, env)
qᵢ = 1
init_plus_phase_state!(nophase, qureg, qᵢ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_initialise_qubit_state.jl#L29-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_plus_phase_state!-Tuple{Phase, Any, Any, Any}" href="#RobustBlindVerification.init_plus_phase_state!-Tuple{Phase, Any, Any, Any}"><code>RobustBlindVerification.init_plus_phase_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_plus_phase_state!(phase::Phase, qureg, qᵢ, φᵢ)</code></pre><p>This function initializes a quantum state to a superposition state (|+⟩ state) with a specified phase.  It first applies a Hadamard gate to the qubit, putting it into a superposition state.  Then it applies a Z rotation to the qubit, adding the specified phase.</p><p><strong>Arguments</strong></p><ul><li><code>phase::Phase</code>: The phase object.</li><li><code>qureg</code>: The quantum register containing the qubit.</li><li><code>qᵢ</code>: The index of the qubit in the quantum register.</li><li><code>φᵢ</code>: The phase to be added to the qubit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">phase = Phase()
qureg = createQureg(1, env)
qᵢ = 1
φᵢ = π/2
init_plus_phase_state!(phase, qureg, qᵢ, φᵢ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_initialise_qubit_state.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_qubit-Tuple{DummyQubit}" href="#RobustBlindVerification.init_qubit-Tuple{DummyQubit}"><code>RobustBlindVerification.init_qubit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_qubit(::DummyQubit)::Int64</code></pre><p>This function is used to initialize the qubit in the meta graph.  The state is not given, but the bit for the initial state of the dummy qubit is returned.</p><p><strong>Arguments</strong></p><ul><li><code>dummy::DummyQubit</code>: The DummyQubit object.</li></ul><p><strong>Returns</strong></p><ul><li>An Int64 representing the bit for the initial state of the dummy qubit.</li></ul><p><strong>Examples</strong></p><p><code>julia dummy = DummyQubit() bit = init_qubit(dummy)</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L343-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_qubit-Tuple{TrapQubit}" href="#RobustBlindVerification.init_qubit-Tuple{TrapQubit}"><code>RobustBlindVerification.init_qubit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_qubit(::TrapQubit)::Float64</code></pre><p>This function is used to initialize the qubit in the meta graph.  The state is not given, but the angle for the plus phase state for a trap qubit is returned.</p><p><strong>Arguments</strong></p><ul><li><code>trap::TrapQubit</code>: The TrapQubit object.</li></ul><p><strong>Returns</strong></p><ul><li>A Float64 representing the angle for the plus phase state for a trap qubit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">trap = TrapQubit()
angle = init_qubit(trap)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L320-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, Any, Any}" href="#RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, Any, Any}"><code>RobustBlindVerification.init_qubit_meta_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_qubit_meta_graph!(::Client, resource, mg)</code></pre><p>This function initializes the qubit meta graph for a client in the MBQC model.  It retrieves the round type from the meta graph and then calls the appropriate  <code>init_qubit_meta_graph!</code> function based on the round type.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_prop!(mg, :round_type, ComputationRound())
init_qubit_meta_graph!(client, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L431-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, ComputationRound, MBQCResourceState, Any}" href="#RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, ComputationRound, MBQCResourceState, Any}"><code>RobustBlindVerification.init_qubit_meta_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_qubit_meta_graph!(::Client, ::ComputationRound, resource::MBQCResourceState, mg)</code></pre><p>This function initializes the qubit meta graph for a client in the MBQC model during a computation round.  It sets the secret angle and initial qubit properties for each vertex in the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>::ComputationRound</code>: The ComputationRound object.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
round = ComputationRound()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
init_qubit_meta_graph!(client, round, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L366-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, MBQC, MBQCResourceState, Any}" href="#RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, MBQC, MBQCResourceState, Any}"><code>RobustBlindVerification.init_qubit_meta_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_qubit_meta_graph!(::Client, mbqc::MBQC, resource::MBQCResourceState, mg)</code></pre><p>This function initializes the qubit meta graph for a client in the MBQC model.  It sets the secret angle and initial qubit properties for each vertex in the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The Client object.</li><li><code>mbqc::MBQC</code>: The MBQC object.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
mbqc = MBQC()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
init_qubit_meta_graph!(client, mbqc, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L285-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, TestRound, MBQCResourceState, Any}" href="#RobustBlindVerification.init_qubit_meta_graph!-Tuple{Client, TestRound, MBQCResourceState, Any}"><code>RobustBlindVerification.init_qubit_meta_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_qubit_meta_graph!(::Client, ::TestRound, resource::MBQCResourceState, mg)</code></pre><p>This function initializes the qubit meta graph for a client in the MBQC model during a test round.  It sets the initial qubit property for each vertex in the meta graph based on the vertex type.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>::TestRound</code>: The TestRound object.</li><li><code>resource::MBQCResourceState</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
round = TestRound()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
init_qubit_meta_graph!(client, round, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L399-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.initialise_quantum_state_meta_graph!-Tuple{Client, Union{DensityMatrix, StateVector}, Any}" href="#RobustBlindVerification.initialise_quantum_state_meta_graph!-Tuple{Client, Union{DensityMatrix, StateVector}, Any}"><code>RobustBlindVerification.initialise_quantum_state_meta_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialise_quantum_state_meta_graph!(::Client, state_type::Union{StateVector,DensityMatrix}, mg)</code></pre><p>This function initializes the quantum state of a meta graph for a client in the MBQC model.  It first creates a quantum environment and a quantum state of the specified type.  Then, for each vertex in the meta graph, it gets the vertex type, vertex IO type, and initial qubit value,  and uses these to initialize the qubit in the quantum state.  Finally, it sets the quantum state as a property of the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>state_type::Union{StateVector,DensityMatrix}</code>: The type of quantum state to create.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
mg = MetaGraphs.MetaGraph(graph)
state_type = StateVector()
initialise_quantum_state_meta_graph!(client, state_type, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L664-L688">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.initialise_quantum_state_meta_graph!-Tuple{MBQC, Client, Union{DensityMatrix, StateVector}, Any}" href="#RobustBlindVerification.initialise_quantum_state_meta_graph!-Tuple{MBQC, Client, Union{DensityMatrix, StateVector}, Any}"><code>RobustBlindVerification.initialise_quantum_state_meta_graph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialise_quantum_state_meta_graph!(mbqc::MBQC, client::Client, state_type::Union{StateVector,DensityMatrix}, mg)</code></pre><p>This function initializes the quantum state of a meta graph for a client in the MBQC model.  It first creates a quantum environment and a quantum state of the specified type.  Then, for each vertex in the meta graph, it gets the vertex type and vertex IO type,  and uses these to initialize the qubit in the quantum state.  Finally, it sets the quantum state as a property of the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>::MBQC</code>: The MBQC object.</li><li><code>::Client</code>: The Client object.</li><li><code>state_type::Union{StateVector,DensityMatrix}</code>: The type of quantum state to create.</li><li><code>mg</code>: The MetaGraph to which the properties will be added.</li></ul><p><strong>Returns</strong></p><ul><li>The updated MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mbqc = MBQC()
client = Client()
mg = MetaGraphs.MetaGraph(graph)
state_type = StateVector()
initialise_quantum_state_meta_graph!(mbqc, client, state_type, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L708-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.initialise_qubit-Tuple{DummyQubit, NoInputQubits, Any, Any, Int64}" href="#RobustBlindVerification.initialise_qubit-Tuple{DummyQubit, NoInputQubits, Any, Any, Int64}"><code>RobustBlindVerification.initialise_qubit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialise_qubit(dummy::DummyQubit, noinput::NoInputQubits, quantum_state, qubit_index, qubit_input_value::Int)</code></pre><p>This function initialises a qubit in a quantum state. If the input value for the qubit is zero, it does nothing.  If the input value is one, it applies a Pauli-X gate to the qubit. If the input value is neither zero nor one,  it throws a <code>DummyQubitZeroOneInitialisationError</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dummy::DummyQubit</code>: The DummyQubit object.</li><li><code>noinput::NoInputQubits</code>: The NoInputQubits object.</li><li><code>quantum_state</code>: The quantum state containing the qubit.</li><li><code>qubit_index</code>: The index of the qubit in the quantum state.</li><li><code>qubit_input_value::Int</code>: The input value for the qubit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">dummy = DummyQubit()
noinput = NoInputQubits()
quantum_state = createQureg(1, env)
qubit_index = 1
qubit_input_value = 0
initialise_qubit(dummy, noinput, quantum_state, qubit_index, qubit_input_value)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_initialise_qubit_state.jl#L53-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.initialise_qubit-Tuple{MBQC, Union{ComputationQubit, TrapQubit}, Union{InputQubits, NoInputQubits}, Any, Any}" href="#RobustBlindVerification.initialise_qubit-Tuple{MBQC, Union{ComputationQubit, TrapQubit}, Union{InputQubits, NoInputQubits}, Any, Any}"><code>RobustBlindVerification.initialise_qubit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialise_qubit(mbqc::MBQC, qubit::Union{ComputationQubit,TrapQubit}, input::Union{InputQubits,InputQubits,NoInputQubits}, quantum_state, qubit_index)</code></pre><p>This function initialises a qubit in a quantum state to a superposition state without adding any phase.  It applies a Hadamard gate to the qubit, putting it into a superposition state.</p><p><strong>Arguments</strong></p><ul><li><code>mbqc::MBQC</code>: The MBQC object.</li><li><code>qubit::Union{ComputationQubit,TrapQubit}</code>: The type of the qubit.</li><li><code>input::Union{InputQubits,InputQubits,NoInputQubits}</code>: The input object.</li><li><code>quantum_state</code>: The quantum state containing the qubit.</li><li><code>qubit_index</code>: The index of the qubit in the quantum state.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mbqc = MBQC()
qubit = ComputationQubit()
input = InputQubits()
quantum_state = createQureg(1, env)
qubit_index = 1
initialise_qubit(mbqc, qubit, input, quantum_state, qubit_index)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_initialise_qubit_state.jl#L114-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.initialise_qubit-Tuple{Union{ComputationQubit, TrapQubit}, Union{InputQubits, NoInputQubits}, Any, Any, Float64}" href="#RobustBlindVerification.initialise_qubit-Tuple{Union{ComputationQubit, TrapQubit}, Union{InputQubits, NoInputQubits}, Any, Any, Float64}"><code>RobustBlindVerification.initialise_qubit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialise_qubit(qubit::Union{ComputationQubit,TrapQubit}, input::Union{InputQubits,InputQubits,NoInputQubits}, quantum_state, qubit_index, qubit_input_value::Float64)</code></pre><p>This function initialises a qubit in a quantum state with a phase determined by the input value.  If the input value is a float, it initialises the qubit to a superposition state with the input value as the phase.  If the input value is not a float, it throws a <code>QubitFloatPhaseInitialisationError</code>.</p><p><strong>Arguments</strong></p><ul><li><code>qubit::Union{ComputationQubit,TrapQubit}</code>: The type of the qubit.</li><li><code>input::Union{InputQubits,InputQubits,NoInputQubits}</code>: The input object.</li><li><code>quantum_state</code>: The quantum state containing the qubit.</li><li><code>qubit_index</code>: The index of the qubit in the quantum state.</li><li><code>qubit_input_value::Float64</code>: The input value for the qubit, which determines the phase.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">qubit = ComputationQubit()
input = InputQubits()
quantum_state = createQureg(1, env)
qubit_index = 1
qubit_input_value = 0.5
initialise_qubit(qubit, input, quantum_state, qubit_index, qubit_input_value)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_initialise_qubit_state.jl#L84-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.measure_along_ϕ_basis!-Tuple{Client, Any, Union{Int32, Int64}, Float64}" href="#RobustBlindVerification.measure_along_ϕ_basis!-Tuple{Client, Any, Union{Int32, Int64}, Float64}"><code>RobustBlindVerification.measure_along_ϕ_basis!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">measure_along_ϕ_basis!(client::Client, ψ, v::Union{Int32,Int64}, ϕ::Float64)</code></pre><p>This function measures a quantum state along a specific basis.  It first applies a Z rotation to the state, then applies a Hadamard gate,  and finally performs a measurement. The basis is determined by the angle ϕ.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The Client object.</li><li><code>ψ</code>: The quantum state to be measured.</li><li><code>v::Union{Int32,Int64}</code>: The vertex on which the operations are applied.</li><li><code>ϕ::Float64</code>: The angle determining the basis for measurement.</li></ul><p><strong>Returns</strong></p><ul><li>The result of the measurement.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
ψ = QuantumState()
v = 1
ϕ = π/4
measure_along_ϕ_basis!(client, ψ, v, ϕ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L1011-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.produce_initialised_graph-Tuple{Client, Any}" href="#RobustBlindVerification.produce_initialised_graph-Tuple{Client, Any}"><code>RobustBlindVerification.produce_initialised_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">produce_initialised_graph(::Client, mg)</code></pre><p>This function produces an initialised graph from a meta graph for a client in the MBQC model.  It simply creates a new graph from the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph to be converted into a graph.</li></ul><p><strong>Returns</strong></p><ul><li>A new Graph created from the MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
mg = MetaGraphs.MetaGraph(graph)
produce_initialised_graph(client, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L964-L983">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.produce_initialised_qureg-Tuple{Client, Any}" href="#RobustBlindVerification.produce_initialised_qureg-Tuple{Client, Any}"><code>RobustBlindVerification.produce_initialised_qureg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">produce_initialised_qureg(client::Client, mg)</code></pre><p>This function retrieves the quantum state from a meta graph for a client in the MBQC model.  It uses the <code>get_prop</code> function to get the <code>:quantum_state</code> property from the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The Client object.</li><li><code>mg</code>: The MetaGraph from which the quantum state will be retrieved.</li></ul><p><strong>Returns</strong></p><ul><li>The quantum state of the MetaGraph.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
mg = MetaGraphs.MetaGraph(graph)
produce_initialised_qureg(client, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L988-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.rand_k_0_7-Tuple{}" href="#RobustBlindVerification.rand_k_0_7-Tuple{}"><code>RobustBlindVerification.rand_k_0_7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Draw random interger between 0 and 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_random_draw_functions_angle_bits.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.separate_each_color-Tuple{Graphs.Coloring{Int64}}" href="#RobustBlindVerification.separate_each_color-Tuple{Graphs.Coloring{Int64}}"><code>RobustBlindVerification.separate_each_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">separate_each_color(g::Graphs.Coloring{Int64})</code></pre><p>This function extracts from a <code>Graphs.Coloring{Int64}</code> and returns a <code>Vector{Vector{Int64}}</code>.  Once a coloring is selected, a vector of integers will result where:</p><ul><li>1 represents a Dummy vertex</li><li>2 represents a Trap</li></ul><p><strong>Arguments</strong></p><ul><li><code>g::Graphs.Coloring{Int64}</code>: The graph coloring object.</li></ul><p><strong>Examples</strong></p><p><code>julia g = Graphs.grid_graph((5,5)) coloring = Graphs.greedy_color(g) separate_each_color(coloring)</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L23-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_io_qubits_type!-Tuple{Client, Any, Any}" href="#RobustBlindVerification.set_io_qubits_type!-Tuple{Client, Any, Any}"><code>RobustBlindVerification.set_io_qubits_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_io_qubits_type!(::Client, resource, mg)</code></pre><p>This function sets the input/output qubits type property in a MetaGraph based on the round type property of the MetaGraph. </p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The Client object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex io type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_prop!(mg, :round_type, ComputationRound())
set_io_qubits_type!(client, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L260-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_io_qubits_type!-Tuple{ComputationRound, Any, Any}" href="#RobustBlindVerification.set_io_qubits_type!-Tuple{ComputationRound, Any, Any}"><code>RobustBlindVerification.set_io_qubits_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_io_qubits_type!(::ComputationRound, resource, mg)</code></pre><p>In Computation round, there are sometimes input values for qubits. When this happens, this function will allocate space for them in the property graph.  It assigns the <code>InputQubits</code> type to the vertices that are in the input indices and <code>NoInputQubits</code> to the rest.</p><p><strong>Arguments</strong></p><ul><li><code>round::ComputationRound</code>: The ComputationRound object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex io type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">round = ComputationRound()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_io_qubits_type!(round, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L204-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_io_qubits_type!-Tuple{MBQC, Any, Any}" href="#RobustBlindVerification.set_io_qubits_type!-Tuple{MBQC, Any, Any}"><code>RobustBlindVerification.set_io_qubits_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_io_qubits_type!(::MBQC, resource, mg)</code></pre><p>This function sets the input/output qubits type property in a MetaGraph for MBQC with no blind.  It assigns the <code>InputQubits</code> type to the vertices that are in the input indices and <code>NoInputQubits</code> to the rest.</p><p><strong>Arguments</strong></p><ul><li><code>client::MBQC</code>: The MBQC client object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex io type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = MBQC()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_io_qubits_type!(client, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L174-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_io_qubits_type!-Tuple{TestRound, Any, Any}" href="#RobustBlindVerification.set_io_qubits_type!-Tuple{TestRound, Any, Any}"><code>RobustBlindVerification.set_io_qubits_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_io_qubits_type!(::TestRound, resource, mg)</code></pre><p>In Test rounds there is no classical input, but this holder function allows for unilateral call, regardless of round.  It assigns the <code>NoInputQubits</code> type to all the vertices.</p><p><strong>Arguments</strong></p><ul><li><code>round::TestRound</code>: The TestRound object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex io type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">round = TestRound()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_io_qubits_type!(round, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L234-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_vertex_type!-Tuple{Client, Any, Any}" href="#RobustBlindVerification.set_vertex_type!-Tuple{Client, Any, Any}"><code>RobustBlindVerification.set_vertex_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vertex_type!(::Client, resource, mg)</code></pre><p>This function sets the vertex type property in a MetaGraph based on the round type property of the MetaGraph.  It must be implemented after the round type is implemented.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The Client object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_prop!(mg, :round_type, ComputationRound())
set_vertex_type!(client, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L147-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_vertex_type!-Tuple{TestRound, Any, Any}" href="#RobustBlindVerification.set_vertex_type!-Tuple{TestRound, Any, Any}"><code>RobustBlindVerification.set_vertex_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vertex_type!(::TestRound, resource, mg)</code></pre><p>This function sets the vertex type property in a MetaGraph based on a random color pattern from the test round in the resource graph.  It assigns the <code>DummyQubit</code> and <code>TrapQubit</code> types to the vertices according to the color pattern.</p><p><strong>Arguments</strong></p><ul><li><code>test_round::TestRound</code>: The TestRound object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">test_round = TestRound()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_vertex_type!(test_round, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L116-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.set_vertex_type!-Tuple{Union{ComputationRound, MBQC}, Any, Any}" href="#RobustBlindVerification.set_vertex_type!-Tuple{Union{ComputationRound, MBQC}, Any, Any}"><code>RobustBlindVerification.set_vertex_type!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_vertex_type!(::Union{MBQC,ComputationRound}, resource, mg)</code></pre><p>This function sets the vertex type property in a MetaGraph based on the color pattern of the computation round in the resource graph.  It assigns the <code>ComputationQubit</code> type to the vertices according to the color pattern.</p><p><strong>Arguments</strong></p><ul><li><code>mbqc::Union{MBQC,ComputationRound}</code>: The MBQC or ComputationRound object.</li><li><code>resource</code>: The resource containing the graph and its coloring.</li><li><code>mg</code>: The MetaGraph to which the vertex type property will be added.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mbqc = MBQC()
resource = MBQCResourceState(graph)
mg = MetaGraphs.MetaGraph(resource.graph.graph)
set_vertex_type!(mbqc, resource, mg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L88-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.store_measurement_outcome!-Tuple{Client, Any, Any, Any}" href="#RobustBlindVerification.store_measurement_outcome!-Tuple{Client, Any, Any, Any}"><code>RobustBlindVerification.store_measurement_outcome!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">store_measurement_outcome!(client::Client, client_meta_graph, qubit, outcome)</code></pre><p>This function stores the measurement outcome of a specific qubit in the client&#39;s meta graph.  It uses the <code>set_p</code> function to set the property in the meta graph.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The Client object.</li><li><code>client_meta_graph</code>: The MetaGraph where the measurement outcome will be stored.</li><li><code>qubit</code>: The qubit whose measurement outcome is being stored.</li><li><code>outcome</code>: The measurement outcome to be stored.</li></ul><p><strong>Returns</strong></p><ul><li>Nothing. The function modifies the client<em>meta</em>graph in-place.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
client_meta_graph = MetaGraphs.MetaGraph(graph)
qubit = 1
outcome = 0
store_measurement_outcome!(client, client_meta_graph, qubit, outcome)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_meta_graph_resource.jl#L1044-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.update_measurement-Tuple{Client, Any, Any, Any}" href="#RobustBlindVerification.update_measurement-Tuple{Client, Any, Any, Any}"><code>RobustBlindVerification.update_measurement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_measurement(client::Client, q, mg, outcome)</code></pre><p>This function retrieves the round type from the measurement graph and then calls the <code>update_measurement</code> function  with the client, round type, qubit, measurement graph, and outcome as arguments.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the measurement is being updated.</li><li><code>q</code>: The qubit for which the measurement is being updated.</li><li><code>mg</code>: The measurement graph associated with the computation round.</li><li><code>outcome</code>: The outcome of the measurement.</li></ul><p><strong>Returns</strong></p><ul><li>The result of calling <code>update_measurement</code> with the client, round type, qubit, measurement graph, and outcome.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
q = 1
mg = MeasurementGraph()
outcome = 0
update_measurement(client, q, mg, outcome)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L135-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.update_measurement-Tuple{Client, ComputationRound, Any, Any, Any}" href="#RobustBlindVerification.update_measurement-Tuple{Client, ComputationRound, Any, Any, Any}"><code>RobustBlindVerification.update_measurement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_measurement(client::Client, round::ComputationRound, q, mg, outcome)</code></pre><p>Update the measurement for a given computation round and qubit. The function retrieves the one-time pad integer  associated with the qubit and computes the absolute difference between the outcome and the one-time pad integer.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the measurement is being updated.</li><li><code>round::ComputationRound</code>: The computation round for which the measurement is being updated.</li><li><code>q</code>: The qubit for which the measurement is being updated.</li><li><code>mg</code>: The measurement graph associated with the computation round.</li><li><code>outcome</code>: The outcome of the measurement.</li></ul><p><strong>Returns</strong></p><ul><li>The absolute difference between the outcome and the one-time pad integer.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
round = ComputationRound()
q = 1
mg = MeasurementGraph()
outcome = 0
update_measurement(client, round, q, mg, outcome)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L73-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.update_measurement-Tuple{Client, Union{MBQC, TestRound}, Any, Any, Any}" href="#RobustBlindVerification.update_measurement-Tuple{Client, Union{MBQC, TestRound}, Any, Any, Any}"><code>RobustBlindVerification.update_measurement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_measurement(client::Client, round::Union{MBQC, TestRound}, q, mg, outcome)</code></pre><p>This function is used in the context of Measurement-Based Quantum Computing (MBQC) or during a test round.  It takes an outcome and simply returns it without making any modifications.</p><p><strong>Arguments</strong></p><ul><li><code>client::Client</code>: The client for which the measurement is being updated.</li><li><code>round::Union{MBQC, TestRound}</code>: Specifies whether the computation round is a part of MBQC or a test round.</li><li><code>q</code>: The qubit for which the measurement is being updated.</li><li><code>mg</code>: The measurement graph associated with the computation round.</li><li><code>outcome</code>: The outcome of the measurement.</li></ul><p><strong>Returns</strong></p><ul><li>The same <code>outcome</code> that was passed as an argument.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">client = Client()
round = MBQC()
q = 1
mg = MeasurementGraph()
outcome = 0
update_measurement(client, round, q, mg, outcome)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L104-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.ClusterState" href="#RobustBlindVerification.ClusterState"><code>RobustBlindVerification.ClusterState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusterState

A struct representing the cluster state in the MBQC framework.

# Description
`ClusterState` is a marker struct used to represent the cluster state in an MBQC computation. It can be used in combination with other data structures or algorithms specific to the cluster state model.

# Example
```julia
# Declare cluster state
cluster_state = ClusterState()
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L60-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.InputQubits" href="#RobustBlindVerification.InputQubits"><code>RobustBlindVerification.InputQubits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InputQubits

A struct representing input qubits in the MBQC framework.

# Description
`InputQubits` is a marker struct used to indicate the presence of input qubits in an MBQC computation. It is typically used in combination with other data structures or algorithms to handle input qubits in the computation.

# Example
```julia
# Declare input qubits
input_qubits = InputQubits()
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L25-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCAngles" href="#RobustBlindVerification.MBQCAngles"><code>RobustBlindVerification.MBQCAngles</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCAngles(angles) 

- Struct representing the angles associated to the graph. The number of angles will be the same as the vertices in the graph.

# Parameters
- `angles`: A listed set of values, as long as the angles are indexable in the same ways that the vertices are.

# Example
```
julia&gt; angles = [π,π/4,5π/4,7π/4]
julia&gt; mbqc_angles = MBQCAngles(angles) 
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L198-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCFlow" href="#RobustBlindVerification.MBQCFlow"><code>RobustBlindVerification.MBQCFlow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCFlow(forward_flow, backward_flow)

Struct representing flow in MBQC.

# Definition of Flow
- `forward_flow`, `f`: Oᶜ → Iᶜ is a mapping `v ↦ f(v)` with an inverse `f⁻¹(v) ↦ v`, with partial order &quot;≤&quot;. The partial order is said to map the present to the future or the present to the past.
- (a) `v ∼ f(v)`, where &quot;∼&quot; defines the neighbourhood `N(f(v))` and `v` has set membership.
- (b) `v ≤ f(v)`
- (c) `w ∼ f(v)`, then ∀ `v`, `v ≤ w`

## Example
- One dimensional lattice, the &quot;path graph&quot;, where a vertex is represented as &quot;()&quot; and an edge is represented as &quot;---&quot;.
- Let `i` be the index of each vertex so that `i = {1, 2, 3, 4}` and
- `p := (1)---(2)---(3)---(4)`
- `f(i) := i + 1`
- `f⁻¹(i) := i - 1`
- `f([1, 2, 3]) = [2, 3, 4]`, since 4 has no future, there is no 4 + 1 answer.
- `f⁻¹([2, 3, 4]) = [1, 2, 3]`, since 1 has no past, there is no 1 - 1 answer.

# Parameters
- `forward_flow`: A mapping to take an input vertex and return the output vertex such that the definitions of flow hold. The forward flow function can be any container that takes a vertex index as input and outputs a new vertex index.
- `backward_flow`: A mapping to take an output vertex and return the input vertex. The backward flow function maps the inverse of the forward flow.

# Example
```julia
# Define forward and backward flow functions
forward_flow(io) = io[2]
backward_flow(io) = io[1]

# Create an MBQCFlow
mbqc_flow = MBQCFlow(forward_flow, backward_flow)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L155-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCGraph" href="#RobustBlindVerification.MBQCGraph"><code>RobustBlindVerification.MBQCGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCGraph(graph,input,output)

- Struct representing the graph used in the MBQC. Container holds the graph as well as the input and output sets.

# Parameters
- `graph`: Any graph suitable for MBQC
- `input`: has type MBQCInput
- `output`: had type MBQCOutput

# Example
```
julia&gt; using Graphs # use using Pkg; Pkg.add(&quot;Graphs&quot;) is not installede
julia&gt; graph = Graphs.grid([1,4]) # 1D cluster graph (path graph) on 4 vertices
julia&gt; indices,values = (1),(0)
julia&gt; input  = MBQCInput(indices,values)
julia&gt; indices = (4)
julia&gt; output  = MBQCOutput(indices)
julia&gt; mbqc_graph = MBQCGraph(graph,input,output)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L127-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCInput" href="#RobustBlindVerification.MBQCInput"><code>RobustBlindVerification.MBQCInput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCInput(indices,values)

- Struct representing an input set into the graph, can be empty

# Parameters
- `indices`: has type Tuple on normally integers (whole numbers 1 to N) and correspond to vertices in a graph.
- `values`: has type Tuple, can be any type

# Example
```
julia&gt; indices = (1,2,3,4)
julia&gt; values = (0,1,1,0) #Computational basis outcomes
julia&gt; mbqc_input = MBQCInput(indices,values)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L81-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCMeasurementOutcomes" href="#RobustBlindVerification.MBQCMeasurementOutcomes"><code>RobustBlindVerification.MBQCMeasurementOutcomes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCMeasurementOutcomes(outcomes)

Struct representing measurement outcomes in MBQC.

# Parameter
- `outcomes`: An array or container representing the measurement outcomes.

## Example
```julia
# Define measurement outcomes
outcomes = [0, 1, 1, 0]

# Create an MBQCMeasurementOutcomes
measurement_outcomes = MBQCMeasurementOutcomes(outcomes)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L250-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCOutput" href="#RobustBlindVerification.MBQCOutput"><code>RobustBlindVerification.MBQCOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCOutput(indices)

- Struct representing an output set into the graph, can be empty.

# Parameters
- `indices`: has type Tuple on normally integers (whole numbers 1 to N) and correspond to the vertices in a graph.


# Example
```
julia&gt; indices = (10,11,12)
julia&gt; mbqc_output = MBQCOutput(indices)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.MBQCResourceState" href="#RobustBlindVerification.MBQCResourceState"><code>RobustBlindVerification.MBQCResourceState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MBQCResourceState(graph, flow, angles)

Struct representing a resource state in MBQC.

# Parameters
- `graph`: An instance of `MBQCGraph` representing the underlying graph structure.
- `flow`: An instance of `MBQCFlow` representing the flow in the resource state.
- `angles`: An instance of `MBQCAngles` representing the angles associated with each vertex.

## Example
```julia
# Create an MBQCGraph
graph = MBQCGraph([1, 2, 3], [(1, 2), (2, 3)])

# Create an MBQCFlow
flow = MBQCFlow((1, 2) =&gt; 2, (2, 3) =&gt; 3)

# Create an MBQCAngles
angles = MBQCAngles([π/2, π/4, π/3])

# Create an MBQCResourceState
resource_state = MBQCResourceState(graph, flow, angles)
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L217-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.NoInputQubits" href="#RobustBlindVerification.NoInputQubits"><code>RobustBlindVerification.NoInputQubits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoInputQubits

A struct representing the absence of input qubits in the MBQC framework.

# Description
`NoInputQubits` is a marker struct used to indicate the absence of input qubits in an MBQC computation. It can be used as a flag or placeholder to handle scenarios where there are no input qubits in the computation.

# Example
```julia
# Declare absence of input qubits
no_input_qubits = NoInputQubits()
```</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_server_structs.jl#L42-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RobustBlindVerification.NoisyClient" href="#RobustBlindVerification.NoisyClient"><code>RobustBlindVerification.NoisyClient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    NoisyClient(noise_model::Union{Vector{NoiseModel}, NoiseModel})</code></pre><p>For MBQC only. A structure representing a client that operates under some noise model. May be buggy.</p><p><strong>Fields</strong></p><ul><li><code>noise_model::Union{Vector{NoiseModel}, NoiseModel}</code>: The noise model under which the client operates.    This can be a single <code>NoiseModel</code> or a vector of <code>NoiseModel</code>s.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">noise_model = NoiseModel()
client = NoisyClient(noise_model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fieldofnodes/RobustBlindVerification.jl/blob/47cefbc3d8eceb6d7c8c8df72db761f80b89e594/src/client_functions.jl#L164-L180">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 8 February 2024 19:03">Thursday 8 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
